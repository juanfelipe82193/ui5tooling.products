'use strict';
const
    xsenv = require('@sap/xsenv'),
    utils = require('../lib/utils'),
    jszip = require('jszip'),
    fs = require('fs'),
    axios = require('axios'),
    glob = require('glob'),
    FormData = require('form-data'),
    rimraf = require('rimraf'),
    path = require('path'),
    url = require('url'),
    TIMEOUT = 300000;

const SAP_CONTENT_PROVIDER = process.env.SAP_CONTENT_PROVIDER === 'true';
const SAP_CONTENT_PROVIDER_XSAPPNAME = process.env.SAP_CONTENT_PROVIDER_XSAPPNAME;
const SAP_LOCAL_CONTENT_PROVIDER = process.env.SAP_LOCAL_CONTENT_PROVIDER === 'true';
const DTS_IMPORT_URL = '/dts/api/v1/transport/import';
const DTS_IMPORT_CONTENT_PROVIDER_URL = '/dts/api/v1/transport/importSAPProvider';

/*
    Create Archive from files within site folder (design time site and i18n translations)
    receive structure:
    - portal-site
          CommonDataModel.json
          - i18n
               *.properties

     create zip file structure:
     - site
        CommonDataModel.json
        i18n/
            *.properties

     */
function getArchiveStream() {
    return new Promise((resolve, reject) => {
            try {
                let buildDirectory = path.normalize(process.cwd() + '/deploymentTemp');
                if (!fs.existsSync(buildDirectory)) {
                    if (!fs.existsSync(buildDirectory)) {
                        fs.mkdirSync(buildDirectory);
                    }
                    let zip = new jszip();
                    let options = {cwd: process.cwd()};

                    // Matches only *.json or *.properties inside folder "portal-site", "portal-site\i18n" and "portal-site\business-apps"
                    let cdmPath = `${path.sep}CommonDataModel.json`;
                    let translationFilesPath = `${path.sep}i18n${path.sep}*.properties`;
                    let businessAppFilesPath = `${path.sep}business-apps${path.sep}*.json`;
                    let snapshotBusinessAppFilesPath = `${path.sep}snapshot-business-apps${path.sep}*.json`;

                    let pattern = `portal-site{${cdmPath},${translationFilesPath},${businessAppFilesPath},${snapshotBusinessAppFilesPath}}`;

                    glob(pattern, options, (err, files) => {
                        files.forEach((filePath) => {
                            let fileData = fs.readFileSync(filePath);

                            //getting folder name 'portal-site', need to generate folder 'site'
                            filePath = filePath.substring('portal-'.length);
                            zip.file(filePath, fileData);
                        });
                        resolve(zip.generateNodeStream());
                    });
                }
            } catch
                (err) {
                console.error('flp-ct-content-deployer failed creating zip file before sending to portal service: ', err.message);
                reject(err)
            }
        }
    );
}

function deleteArchive() {
    return new Promise((resolve, reject) => {
        try {
            let buildDirectory = path.normalize(process.cwd() + '/deploymentTemp');
            rimraf(buildDirectory, (err) => {
                if (err) {
                    console.error('Failed to delete temporary archive folder: ', err.message);
                    return reject(err);
                }
                console.log('deleteArchive: deploymentTemp folder was deleted successfully');
                return resolve();
            });
        } catch (err) {
            return reject(err);
        }
    });
}

/*
    Fetch the apphostIds from bounded services.
    Deployer is bound to html5-repo deployer instance and to the business services
*/
function fetchAppHostIdsXsAppNameServicesMap() {
    return new Promise((resolve) => {
        let result = {
            appHostIds:
                {
                    'appHostIds': [],
                    'boundAppHostIds': []
                },
            xsAppNameServicesMap: {}
        };

        //extract main app_host_id --> deployer is bound to html5-repo deployer instance
        try {
            let serviceCredentials = xsenv.filterCFServices({tag: 'html5-apps-repo-dt'});
            let arr = [];
            for (let i = 0; i < serviceCredentials.length; i++) {
                let credentials = serviceCredentials[i].credentials;
                if (credentials && credentials['app_host_id']) {
                    let appHostIds = credentials['app_host_id'];
                    //support for multiple app_host_ids
                    if (appHostIds) {
                        for (let appHostId of appHostIds.split(',')) {
                            arr.push(appHostId.trim());
                        }
                    }
                }
            }
            // for SAP Content Provider (External) all appHosts ids treated as Business services
            if (SAP_CONTENT_PROVIDER) {
                result.appHostIds.boundAppHostIds = arr;
            } else {
                result.appHostIds.appHostIds = arr;
            }
        } catch (err) {
            console.error('fetchAppHostIdsXsAppNameServicesMap - main app_host_id exception was thrown: ', err.message);
        }

        //extract main uaa xsappname for xsAppNameServicesMap -> com.sap.portal.no.business.service
        try {
            let serviceCredentials = xsenv.cfServiceCredentials({tag: 'xsuaa'});
            if (serviceCredentials && serviceCredentials.xsappname) {
                result.xsAppNameServicesMap['com.sap.portal.no.business.service'] = serviceCredentials.xsappname;
            } else if (SAP_CONTENT_PROVIDER) {
                console.info('fetchAppHostIdsXsAppNameServicesMap - setting xsAppNameServiceMap with SAP_CONTENT_PROVIDER_XSAPPNAME.');
                result.xsAppNameServicesMap['com.sap.portal.no.business.service'] = SAP_CONTENT_PROVIDER_XSAPPNAME;
            } else {
                console.error('fetchAppHostIdsXsAppNameServicesMap - cannot find main uaa xsappname');
            }

        } catch (err) {
            if (SAP_CONTENT_PROVIDER) {
                console.info('fetchAppHostIdsXsAppNameServicesMap - setting xsAppNameServiceMap with SAP_CONTENT_PROVIDER_XSAPPNAME.');
                result.xsAppNameServicesMap['com.sap.portal.no.business.service'] = SAP_CONTENT_PROVIDER_XSAPPNAME;
            } else {
                console.error('fetchAppHostIdsXsAppNameServicesMap - uaa not bound. err: ', err.message);
            }
        }

        //extract app_host_id's, sap.cloud.service & xsaapname of business services
        try {
            let services = xsenv.readCFServices();
            for (let serviceName of Object.keys(services)) {
                //skip the portal service itself
                let service = services[serviceName];
                if (!service.tags || !service.tags.includes('portal-service')) {
                    let credentials = service.credentials;
                    if (credentials && credentials['html5-apps-repo'] && credentials['html5-apps-repo']['app_host_id']) {
                        let boundAppHostIds = credentials['html5-apps-repo']['app_host_id'];
                        //support for multiple app_host_ids
                        if (boundAppHostIds) {
                            for (let boundAppHostId of boundAppHostIds.split(',')) {
                                result.appHostIds.boundAppHostIds.push(boundAppHostId.trim());
                            }
                        }
                    }
                    //add business service xsappname
                    if (credentials['sap.cloud.service'] && credentials.uaa && credentials.uaa.xsappname) {
                        result.xsAppNameServicesMap[credentials['sap.cloud.service']] = credentials.uaa.xsappname;
                    }
                }
            }
        } catch (err) {
            console.error('fetchAppHostIdsXsAppNameServicesMap - app_host_ids, sap.cloud.service & xsaapname of business services exception was thrown: ', err.message);
        }
        resolve(result);
    });
}

function buildContentProviderMetaData(contentProviderCred, portalServiceCredentials, xsappname, isExternal) {
    let result = {
        providerData: {
            providerType: 'cf',
            data: {
                id: contentProviderCred.appName,
                xsappname: xsappname,
                category: "paas",
                translations: [{
                    locale: '',
                    textDictionary: {
                        title: contentProviderCred.display_name || contentProviderCred.title || contentProviderCred.appName || '',
                        description: contentProviderCred.description || ''
                    }
                }],
                exposedContent: "embedded"
            }
        }
    };
    if (isExternal) {
        result.isExternalContentProvider = 'true';
        result.blueBoxCredData = {
            portalServiceCredentials: portalServiceCredentials
        };
    }
    return result;
}

function fetchBlueBoxMetadata() {
    return new Promise(async (resolve) => {
            let result;
            if (SAP_LOCAL_CONTENT_PROVIDER) {
                try {
                    const contentProviderCred = xsenv.cfServiceCredentials({tag: 'com.sap.portal.content.provider'});
                    const uaaServiceCredentials = xsenv.cfServiceCredentials({tag: 'xsuaa'});
                    result = buildContentProviderMetaData(contentProviderCred, uaaServiceCredentials.xsappname);
                } catch (err) {
                    console.error('fetchBlueBoxMetadata - SAP_LOCAL_CONTENT_PROVIDER, exception was thrown: ', err.message);
                    throw err;
                }

            } else if (SAP_CONTENT_PROVIDER) {
                let xsappname;

                try {
                    let uaaServiceCredentials = xsenv.cfServiceCredentials({tag: 'xsuaa'});

                    if (uaaServiceCredentials && uaaServiceCredentials.xsappname) {
                        xsappname = uaaServiceCredentials.xsappname;
                    } else if (SAP_CONTENT_PROVIDER) {
                        console.info('fetchBlueBoxMetadata - uaa is not bound, setting xsAppNameServiceMap with SAP_CONTENT_PROVIDER_XSAPPNAME.');
                        xsappname = SAP_CONTENT_PROVIDER_XSAPPNAME;
                    } else {
                        console.error('fetchBlueBoxMetadata - uaa not bound. err: ', err.message);
                    }
                } catch (err) {
                    if (SAP_CONTENT_PROVIDER) {
                        console.info('fetchBlueBoxMetadata - uaa is not bound, setting xsappname with SAP_CONTENT_PROVIDER_XSAPPNAME.');
                        xsappname = SAP_CONTENT_PROVIDER_XSAPPNAME;
                    } else {
                        console.error('fetchBlueBoxMetadata - uaa not bound. err: ', err.message);
                    }
                }
                try {
                    const saasServiceCredentials = xsenv.cfServiceCredentials({tag: 'SaaS'});
                    let portalServiceCredentials = xsenv.cfServiceCredentials({tag: 'portal-service'});
                    result = buildContentProviderMetaData(saasServiceCredentials, portalServiceCredentials, xsappname, true);
                } catch (err) {
                    console.error('fetchBlueBoxMetadata - SAP_CONTENT_PROVIDER, exception was thrown: ', err.message);
                    throw err;
                }
            } else {
                const tenantHostPattern = process.env.TENANT_HOST_PATTERN;
                if (tenantHostPattern) {
                    try {
                        const uaaServiceCredentials = xsenv.cfServiceCredentials({tag: 'xsuaa'});
                        const saasServiceCredentials = xsenv.cfServiceCredentials({tag: 'SaaS'});
                        if (saasServiceCredentials && uaaServiceCredentials) {

                            // Extract app-router url
                            let appRouterUrl, appUrls = saasServiceCredentials.appUrls;
                            if (appUrls) {
                                appUrls = JSON.parse(saasServiceCredentials.appUrls);
                                appRouterUrl = url.parse(appUrls.getDependencies).hostname;
                            }

                            // prepare payload
                            result = {
                                providerData: {
                                    providerType: 'cf',
                                    data: {
                                        id: saasServiceCredentials.appName,
                                        deprecatedId: saasServiceCredentials.xsappname && saasServiceCredentials.xsappname.replace(/(!|\|.*)/g, ""),
                                        xsappname: uaaServiceCredentials.xsappname,
                                        url: appRouterUrl,
                                        tenantHostPattern: tenantHostPattern,
                                        category: saasServiceCredentials.category || '',
                                        translations: [{
                                            locale: '',
                                            textDictionary: {
                                                title: saasServiceCredentials.display_name || saasServiceCredentials.appName || '',
                                                description: saasServiceCredentials.description || ''
                                            }
                                        }]
                                    }
                                },
                                blueBoxCredData: {
                                    uaaServiceCredentials: uaaServiceCredentials,
                                    tenantHostPattern: tenantHostPattern
                                }
                            };
                        }
                    } catch (err) {
                        console.error('fetchBlueBoxMetadata - exception was thrown: ', err.message);
                    }
                }
            }
            resolve(result);
        }
    );
}

//Send the zip file and the app_host_ids for deployment to the Portal service
async function portalServiceDeploy(archiveStream, appHostIdsXsAppNameServicesMap, blueBoxData, token) {
    try {
        console.log('portalServiceDeploy sending archive with appHostIdsXsAppNameServicesMap= ' + JSON.stringify(appHostIdsXsAppNameServicesMap));
        if (blueBoxData && blueBoxData.providerData) {
            console.log('portalServiceDeploy sending archive with blueBoxMetadata= ' + JSON.stringify(blueBoxData.providerData));
        }
        let portalService = xsenv.cfServiceCredentials({tag: 'portal-service'});
        let portalURL = portalService.endpoints['portal-service'];
        let dtsImportURL;
        if (SAP_CONTENT_PROVIDER || SAP_LOCAL_CONTENT_PROVIDER) {
            dtsImportURL = `${portalURL}${DTS_IMPORT_CONTENT_PROVIDER_URL}`;
        } else {
            dtsImportURL = `${portalURL}${DTS_IMPORT_URL}`;
        }

        let formData = new FormData();
        formData.append('site', archiveStream, {
            filename: 'site.zip',
            contentType: 'multipart/form-data'
        });
        formData.append('appHostIds', JSON.stringify(appHostIdsXsAppNameServicesMap.appHostIds));
        formData.append('xsAppNameServicesMap', JSON.stringify(appHostIdsXsAppNameServicesMap.xsAppNameServicesMap));
        if (blueBoxData) {
            if (blueBoxData.providerData) {
                formData.append('blueBoxMetadata', JSON.stringify(blueBoxData.providerData));
            }
            if (blueBoxData.blueBoxCredData) {
                formData.append('blueBoxCredData', JSON.stringify(blueBoxData.blueBoxCredData));
            }
            if (blueBoxData.isExternalContentProvider) {
                formData.append('isExternalContentProvider', 'true');
            }
        }
        let headers = formData.getHeaders();
        headers.Authorization = 'Bearer ' + token;
        let requestOptions = {
            headers: headers,
            timeout: TIMEOUT
        };

        console.time("Deploy site elapsed time");
        let response = await axios.post(dtsImportURL, formData, requestOptions);
        if (response) {
            //response success in range of 2xx
            let data = JSON.stringify(response.data);
            console.log(`Portal service deploy success. status = ${response.status}, data: ${data}`);
            return data;
        } else {
            throw new Error('Deploy to portal service failed, Portal service response is undefined');
        }
    } catch (err) {
        let errorMessage = "";
        if (err.response) {
            // The request was made and the server responded with a status code that falls out of the range of 2xx
            errorMessage = 'Deploy to portal service failed, got status = ' + err.response.status + ', data: ' + err.response.data;
        } else if (err.request) {
            // The request was made but no response was received
            errorMessage = 'Deploy to portal service failed, No response received from portal service, error = ' + err.message;
        } else {
            // Something happened in setting up the request that triggered an Error
            errorMessage = 'Deploy to portal service failed, error while setting up request to portal service, error = ' + err.message;
        }
        throw new Error(errorMessage);
    } finally {
        console.timeEnd("Deploy site elapsed time");
    }
}

class DeployUtils {
    /*
    Start the deployment process:
    1. Create archive Zip
    2. Fetch app host ids
    3. Fetch BlueBox metadata for register provider
    4. Fetch technical user token
    5. Send them to the portal service with technical user jwt token
    6. Delete deployment temp folder
     */
    static async deploy() {
        console.log(`deploy flow- SAP_CONTENT_PROVIDER = ${SAP_CONTENT_PROVIDER}, SAP_LOCAL_CONTENT_PROVIDER = ${SAP_LOCAL_CONTENT_PROVIDER}`);
        let results, deployResult;
        try {
            let deployPromises = [];
            deployPromises.push(getArchiveStream());
            deployPromises.push(fetchAppHostIdsXsAppNameServicesMap());
            deployPromises.push(fetchBlueBoxMetadata());
            deployPromises.push(utils.getTechnicalUserToken());
            results = await Promise.all(deployPromises);
            deployResult = await portalServiceDeploy(...results);
            if (deployResult) {
                return deployResult;
            } else {
                throw new Error('Portal service deploy failed with empty result');
            }
        } catch (err) {
            throw new Error(err);
        } finally {
            try {
                await deleteArchive(); //Delete created archive
            } catch (err) {
                console.error('Failed to delete deployment temp folder: ', err.message);
            }
        }
    }
}

module.exports = DeployUtils;
